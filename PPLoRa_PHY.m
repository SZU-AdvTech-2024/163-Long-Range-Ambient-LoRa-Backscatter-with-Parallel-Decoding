%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \file      PPLoRa_PHY.m
%
% \brief     Physical Layer LoRa Modulator/Demodulator/Encoder/Decoder
%
% \version   0.2.1
%
% \repo      https://github.com/jkadbear/PPLoRa_PHY
%
% \copyright MIT License, 2020-2022
%
% \author    jkadbear
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

classdef PPLoRa_PHY < handle & matlab.mixin.Copyable
    %PPLoRa_PHY LoRa physical layer implementation
    %%% Example %%%
    % rf_freq = 470e6;
    % sf = 12;
    % bw = 125e3;
    % fs = 1e6;
    % phy = PPLoRa_PHY(rf_freq, sf, bw, fs);
    % phy.has_header = 1; % explicit header mode
    % symbols = [2541,1153,673,2397,1189,3509,41,3089,3237,3917,2729,2765,1417,2833,1389,801,3197,345,961,745,3101,297,1893,469]';
    % [data, checksum] = phy.decode(symbols);
    % disp(data); % CODE: 09 90 40 01 02 03 04 05 06 07 08 09 BA 2E
    % disp(checksum);

    properties
        rf_freq                   % carrier frequency
        sf                        % spreading factor (7,8,9,10,11,12)
        bw                        % bandwidth (125kHz 250kHz 500kHz)
        fs                        % sampling frequency
        cr                        % code rate: (1:4/5 2:4/6 3:4/7 4:4/8)
        tag_period                % 标签信号的周期
        payload_len               % payload length
        has_header                % explicit header: 1, implicit header: 0
        crc                       % crc = 1 if CRC Check is enabled else 0
        ldr                       % ldr = 1 if Low Data Rate Optimization is enabled else 0
        whitening_seq             % whitening sequence
        crc_generator             % CRC generator with polynomial x^16+x^12+x^5+1
        header_checksum_matrix    % we use a 12 x 5 matrix to calculate header checksum
        preamble_len              % preamble length
        os_ratio

        sig                       % input baseband signal
        downchirp                 % ideal chirp with decreasing frequency from B/2 to -B/2
        upchirp                   % ideal chirp with increasing frequency from -B/2 to B/2
        sample_num                % number of sample points per symbol
        bin_num                   % number of bins after FFT (with zero padding)
        zero_padding_ratio        % FFT zero padding ratio
        fft_len                   % FFT size
        preamble_bin              % reference bin in current decoding window, used to eliminate CFO
        cfo                       % carrier frequency offset
        tag_sample_num            % 标签信号一个周期的采样点
        tag_num                   % 标签的数量

        fast_mode                 % set `true` for fast execution (ignore low-pass filter)
        is_debug                  % set `true` for debug information
        hamming_decoding_en       % enable hamming decoding
    end

    methods
        function self = PPLoRa_PHY(rf_freq, sf, bw, fs, tag_period, tag_num)
            %PPLoRa_PHY Construct an instance of this class

            % Hexadecimal or binary values representation require at least
            % MATLAB R2019b
            % https://www.mathworks.com/help/matlab/matlab_prog/specify-hexadecimal-and-binary-numbers.html
            if verLessThan('matlab', '9.7')
                error('Error. Newer version of MATLAB is required ( >=R2019b ).');
            end

            self.rf_freq = rf_freq;
            self.sf = sf;
            self.bw = bw;
            self.fs = fs;
            self.tag_period = tag_period;
            self.has_header = 1;
            self.crc = 1;
            self.fast_mode = false;
            self.is_debug = false;
            self.hamming_decoding_en = true;
            self.zero_padding_ratio = 16;
            self.cfo = 0;
            self.tag_num = tag_num;

            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % The whitening sequence is generated by an LFSR
            % x^8+x^6+x^5+x^4+1
            % Use the code below to generate such sequence
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % reg = 0xFF;
            % for i = 1:255
            %     fprintf("0x%x, ", reg);
            %     reg = bitxor(bitshift(reg,1), bitxor(bitget(reg,8), bitxor(bitget(reg,6), bitxor(bitget(reg,5), bitget(reg,4)))));
            % end
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            self.whitening_seq = uint8([0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe1, 0xc2, 0x85, 0xb, 0x17, 0x2f, 0x5e, 0xbc, 0x78, 0xf1, 0xe3, 0xc6, 0x8d, 0x1a, 0x34, 0x68, 0xd0, 0xa0, 0x40, 0x80, 0x1, 0x2, 0x4, 0x8, 0x11, 0x23, 0x47, 0x8e, 0x1c, 0x38, 0x71, 0xe2, 0xc4, 0x89, 0x12, 0x25, 0x4b, 0x97, 0x2e, 0x5c, 0xb8, 0x70, 0xe0, 0xc0, 0x81, 0x3, 0x6, 0xc, 0x19, 0x32, 0x64, 0xc9, 0x92, 0x24, 0x49, 0x93, 0x26, 0x4d, 0x9b, 0x37, 0x6e, 0xdc, 0xb9, 0x72, 0xe4, 0xc8, 0x90, 0x20, 0x41, 0x82, 0x5, 0xa, 0x15, 0x2b, 0x56, 0xad, 0x5b, 0xb6, 0x6d, 0xda, 0xb5, 0x6b, 0xd6, 0xac, 0x59, 0xb2, 0x65, 0xcb, 0x96, 0x2c, 0x58, 0xb0, 0x61, 0xc3, 0x87, 0xf, 0x1f, 0x3e, 0x7d, 0xfb, 0xf6, 0xed, 0xdb, 0xb7, 0x6f, 0xde, 0xbd, 0x7a, 0xf5, 0xeb, 0xd7, 0xae, 0x5d, 0xba, 0x74, 0xe8, 0xd1, 0xa2, 0x44, 0x88, 0x10, 0x21, 0x43, 0x86, 0xd, 0x1b, 0x36, 0x6c, 0xd8, 0xb1, 0x63, 0xc7, 0x8f, 0x1e, 0x3c, 0x79, 0xf3, 0xe7, 0xce, 0x9c, 0x39, 0x73, 0xe6, 0xcc, 0x98, 0x31, 0x62, 0xc5, 0x8b, 0x16, 0x2d, 0x5a, 0xb4, 0x69, 0xd2, 0xa4, 0x48, 0x91, 0x22, 0x45, 0x8a, 0x14, 0x29, 0x52, 0xa5, 0x4a, 0x95, 0x2a, 0x54, 0xa9, 0x53, 0xa7, 0x4e, 0x9d, 0x3b, 0x77, 0xee, 0xdd, 0xbb, 0x76, 0xec, 0xd9, 0xb3, 0x67, 0xcf, 0x9e, 0x3d, 0x7b, 0xf7, 0xef, 0xdf, 0xbf, 0x7e, 0xfd, 0xfa, 0xf4, 0xe9, 0xd3, 0xa6, 0x4c, 0x99, 0x33, 0x66, 0xcd, 0x9a, 0x35, 0x6a, 0xd4, 0xa8, 0x51, 0xa3, 0x46, 0x8c, 0x18, 0x30, 0x60, 0xc1, 0x83, 0x7, 0xe, 0x1d, 0x3a, 0x75, 0xea, 0xd5, 0xaa, 0x55, 0xab, 0x57, 0xaf, 0x5f, 0xbe, 0x7c, 0xf9, 0xf2, 0xe5, 0xca, 0x94, 0x28, 0x50, 0xa1, 0x42, 0x84, 0x9, 0x13, 0x27, 0x4f, 0x9f, 0x3f, 0x7f]');

            self.header_checksum_matrix = gf([
                1 1 1 1 0 0 0 0 0 0 0 0
                1 0 0 0 1 1 1 0 0 0 0 1
                0 1 0 0 1 0 0 1 1 0 1 0
                0 0 1 0 0 1 0 1 0 1 1 1
                0 0 0 1 0 0 1 0 1 1 1 1
            ]);

            self.crc_generator = comm.CRCGenerator('Polynomial','X^16 + X^12 + X^5 + 1');

            self.preamble_len = 6;

            self.init();
        end

        function init(self)
            % init  Initialize some parameters

            self.bin_num = 2^self.sf*self.zero_padding_ratio;

            self.os_ratio = self.fs/self.bw;
            self.sample_num = self.os_ratio*2^self.sf;
            self.fft_len = self.sample_num*self.zero_padding_ratio;
            %self.fft_len = 2*self.bin_num;

            

            self.downchirp = PPLoRa_PHY.chirp(false, self.sf, self.bw, self.fs, 0, 0, 0);
            self.upchirp = PPLoRa_PHY.chirp(true, self.sf, self.bw, self.fs, 0, 0, 0);

            % backscatter信号的解调信息的初始化
            self.tag_sample_num = self.tag_period * self.fs;

            % Low Data Rate Optimization (LDRO) mode in LoRa
            % If the chirp peird is larger than 16ms, the least significant
            % two bits are considered unreliable and are neglected.
            if 2^(self.sf)/self.bw > 16e-3
                self.ldr = 1;
            else
                self.ldr = 0;
            end
        end

        function pk = dechirp(self, x, is_up)
            % dechirp  Apply dechirping on the symbol starts from index x
            %
            % input:
            %     x: Start index of a symbol
            %     is_up: `true` if applying up-chirp dechirping
            %            `false` if applying down-chirp dechirping
            % output:
            %     pk: Peak in FFT results of dechirping
            %         pk = (height, index)

            if nargin == 3 && ~is_up
                c = self.upchirp;
            else
                c = self.downchirp;
            end
            ft = fft(self.sig(x:x+self.sample_num-1).*c, self.fft_len);
            %文中的CPA
            ft_ = abs(ft(1:self.bin_num)) + abs(ft(self.fft_len-self.bin_num+1:self.fft_len));
             pk = PPLoRa_PHY.topn([ft_ (1:self.bin_num).'], 1);
        end

        function [pkbin, fftmag_bin, fft_bin] = PPLoRa_dechirp(self, x, down_de, remainder_point, zp_ratio, topn)
            % down_de: wheather use downchirp to dechirp or not
            % 返回topn行解调结果
            % pkbin = [idx fftmag_val fft_val]
        
            if nargin > 2 && ~down_de;  c = self.upchirp;
            else;                       c = self.downchirp;
            end
            if nargin < 4; remainder_point = 0; end
            if nargin < 5; zp_ratio = 16; end
            %每16个bin为一组（对应零填充比例），取其中最大值为这16个bin的峰值，有一个激励信号和一个标签，故取前32个
            if nargin < 6; topn = 1+self.tag_num*2; end
            
            self.zero_padding_ratio = zp_ratio;
            self.fft_len = zp_ratio * self.sample_num;
        
            chirp_sig = self.sig(x : x+self.sample_num-1);
            dechirped = chirp_sig .* c;
            ft = fft(dechirped, self.fft_len);
            fftmag = abs(ft);

            % fftbin的分布，fft_bin为复数，fftmag_bin为abs
            if self.os_ratio >= 2
                % fs>=2bw时，两部分叠加
                % 复数存在正负，所以abs(fft_bin) != fftmag_bin
                % 首先把移出带外的单边带信号叠加一下
                ft(1:self.bin_num/2) = ft(1:self.bin_num/2) + ft(self.bin_num+1:self.bin_num+self.bin_num/2);
                fftmag(1:self.bin_num/2) = fftmag(1:self.bin_num/2) + fftmag(self.bin_num+1:self.bin_num+self.bin_num/2);
                ft(end-self.bin_num/2+1:end) = ft(end-self.bin_num/2+1:end) + ft(end-self.bin_num*1.5+1:end-self.bin_num);
                fftmag(end-self.bin_num/2+1:end) = fftmag(end-self.bin_num/2+1:end) + fftmag(end-self.bin_num*1.5+1:end-self.bin_num);
                % 这一步叠加单边带能量
                fft_bin = ft(1:self.bin_num) + ft(end-self.bin_num+1:end);             % 复数相加
                fftmag_bin = fftmag(1:self.bin_num) + fftmag(end-self.bin_num+1:end);  % 绝对值相加
            else
                % fs=bw的情况
                fft_bin = ft(1:self.bin_num);
                fftmag_bin = fftmag(1:self.bin_num);
            end
            % 这一步先找到激励信号峰值所在，然后返回最大值
            % 翻转集中双边带信号
            [peak_magnitude, peak_index] = maxk(fftmag_bin, 1);
            temp_fftmag_bin = [fftmag_bin(peak_index:end) ;fftmag_bin(1:peak_index-1)];
            temp_fftmag_bin = temp_fftmag_bin + flip(temp_fftmag_bin);
            fftmag_bin = [temp_fftmag_bin(end-(peak_index-1)+1:end);temp_fftmag_bin(1:end-(peak_index-1))];

            % [fftmag_val, idx] = maxk(fftmag_bin, topn * zp_ratio);
            % 对fftbin_num进行排序
            [fftmag_val, idx] = maxk(fftmag_bin, length(fftmag_bin));
    
            % 下面这一段是为了筛选出bin差值大于zp_ratio的频率
    
            % 假设有 fftmag_val 和 idx 作为初始数组，以及给定的 zp_ratio
            n = length(idx);
            keep_mask = true(n, 1);  % 初始标记所有元素为保留
            retained_indices = [];   % 用于存储保留的 idx
            % 以 idx(1) 为中心，设置特殊处理范围
            special_range = 5 * zp_ratio; % 设置范围为 5 * zp_ratio
            within_range_indices = [];
            for i = 1:n
                % 如果当前 idx(i) 与所有已经保留的 idx 的差值都 >= zp_ratio，则保留
                if i == 1
                    % 这里要防止激励信号在边缘，由于fft的频移性质，会有一部分能量在另一个边缘
                    % 这在正常LoRa dechirp中没问题，但是多的这部分会导致标签信号无法正确解调
                    if idx(1) < special_range
                        len = special_range - idx(1);
                        within_range_indices = find(abs(idx - self.bin_num - idx(1)) < len);
                    elseif idx(i) > self.bin_num - special_range
                        len = special_range - (self.bin_num - idx(1));
                        within_range_indices = find(abs(idx + self.bin_num - idx(1)) < len);
                    end
                    within_range_indices = [within_range_indices;find(abs(idx - idx(1)) < special_range)];
                    retained_indices = [idx(within_range_indices)'];  % 记录范围内的索引
                    keep_mask(within_range_indices) = false; % 标记范围内的索引为处理过
                    keep_mask(1) = true; % 保留 idx(1) 自身
                else
                    if all(abs(idx(i) - retained_indices) >= zp_ratio/2)
                        retained_indices = [retained_indices, idx(i)];  % 添加到已保留列表中
                    else
                        keep_mask(i) = false;  % 否则标记为需要删除
                    end
                end
            end
    
            % 根据标记筛选 idx 和 fftmag_val
            idx = idx(keep_mask);
            fftmag_val = fftmag_val(keep_mask);
            % 为了防止fft的频移特性造成错误，所以使用扩展数组来求解
            extended_idx = [idx;idx + self.bin_num];
            extended_fftmag_val = [fftmag_val;fftmag_val];

            % 这里新写一个消除带内干扰的代码
            bin_threshold = self.bin_num / 2;
            below_threshold_indices = find(abs(extended_idx - extended_idx(1)) < bin_threshold);
            
            if ~isempty(below_threshold_indices)
                % 只保留第一个满足条件的 idx，小于 bin_threshold
                keep_mask = true(length(extended_idx), 1);
                keep_mask(below_threshold_indices(2:end)) = false;  % 保留第一个，其余标记为 false
                % 额外清零所有大于等于 idx(1) + self.bin_num 的 idx
                right_half_indices = find(extended_idx >= idx(1) + self.bin_num);
                keep_mask(right_half_indices) = false;  % 清零右半部分
                extended_idx = extended_idx(keep_mask);
                extended_fftmag_val = extended_fftmag_val(keep_mask);
            end
            % end 这里新写一个消除带内干扰的代码
    
            % 只保留一个 idx 小于 self.bin_num / 2 的值
            % 这一步的目的是为了消除带内干扰
            % bin_threshold = self.bin_num / 2;
            % below_threshold_indices = find(abs(idx - idx(1)) < bin_threshold);
            % if ~isempty(below_threshold_indices)
            %     % 只保留第一个满足条件的 idx，小于 bin_threshold
            %     keep_mask = true(length(idx), 1);
            %     keep_mask(below_threshold_indices(2:end)) = false;  % 保留第一个，其余标记为 false
            %     idx = idx(keep_mask);
            %     fftmag_val = fftmag_val(keep_mask);
            % end

            % 根据 extended_fftmag_val 的值排序
            [extended_fftmag_val, sort_order] = sort(extended_fftmag_val, 'descend'); % 降序排列
            extended_idx = extended_idx(sort_order);  % 按排序顺序重新排列 extended_idx

            % 截断 idx 和 fftmag_val 到长度 topn
            if length(extended_idx) > topn
                extended_idx = extended_idx(1:topn);
                extended_fftmag_val = extended_fftmag_val(1:topn);
            end
    
            pkbin = [extended_idx extended_fftmag_val];  % 每行一个bin，总共取topn个bin
        end % PPLoRa_dechirp

        function x = detect(self, start_idx)
            % detect  Detect preamble
            %
            % input:
            %     start_idx: Start index for detection
            % output:
            %     x: Before index x, a preamble is detected.
            %        x = -1 if no preamble detected

            ii = start_idx;
            pk_bin_list = []; % preamble peak bin list
            while ii < length(self.sig)-self.sample_num*self.preamble_len
                % search preamble_len-1 basic upchirps
                %无线环境比较复杂，可以放低前导码要求
                if length(pk_bin_list) == self.preamble_len - 1
                    % preamble detected
                    % coarse alignment: first shift the up peak to position 0
                    % current sampling frequency = 2 * bandwidth
                    x = ii - round((pk_bin_list(end)-1)/self.zero_padding_ratio*2);
                    return;
                end
                pk0 = self.dechirp(ii);
                if ~isempty(pk_bin_list)
                    bin_diff = mod(pk_bin_list(end)-pk0(2), self.bin_num);
                    if bin_diff > self.bin_num/2
                        bin_diff = self.bin_num - bin_diff;
                    end
                    if bin_diff <= self.zero_padding_ratio
                        pk_bin_list = [pk_bin_list; pk0(2)];
                    else
                        pk_bin_list = pk0(2);
                    end
                else
                    pk_bin_list = pk0(2);
                end
                ii = ii + self.sample_num;
            end
            x = -1;
        end

        function [symbols_m, cfo_m, netid_m] = demodulate(self, sig)
            % demodulate  LoRa packet demodulation
            %
            % input:
            %     sig: Baseband signal in complex
            % output:
            %     symbols_m: A matrix containing the demodulated results.
            %                Each column vector represents the symbols of
            %                a successfully demodulated packet.
            %     cfo_m: A vector containing the carrier frequency offset
            %            results. Each element represents the CFO of the
            %            packet in symbols_m.

            self.cfo = 0;
            self.init();

            if ~self.fast_mode
                sig = lowpass(sig, self.bw/2, self.fs);
            end
            % resample signal with 2*bandwidth
            self.sig = resample(sig, 2*self.bw, self.fs);

            symbols_m = [];
            cfo_m = [];
            netid_m = [];
            x = 1;
            while x < length(self.sig)
                x = self.detect(x);
                if x < 0
                    break;
                end

                % align symbols with SFD
                x = self.sync(x);

                % NetID
                pk_netid1 = self.dechirp(round(x-4.25*self.sample_num));
                pk_netid2 = self.dechirp(round(x-3.25*self.sample_num));
                netid_m = [netid_m;
                    [mod((pk_netid1(2)+self.bin_num-self.preamble_bin)/self.zero_padding_ratio, 2^self.sf), ...
                    mod((pk_netid2(2)+self.bin_num-self.preamble_bin)/self.zero_padding_ratio, 2^self.sf)]
                ];

                % the goal is to extract payload_len from PHY header
                % header is in the first 8 symbols
                symbols = [];
                pk_list = [];
                if x > length(self.sig) - 8*self.sample_num + 1
                    return;
                end
                for ii = 0:7
                    pk = self.dechirp(x+ii*self.sample_num);
                    pk_list = [pk_list; pk];
                    symbols = [symbols; mod((pk(2)+self.bin_num-self.preamble_bin)/self.zero_padding_ratio, 2^self.sf)];
                end
                if self.has_header
                    is_valid = self.parse_header(symbols);
                    if ~is_valid
                        x = x + 7*self.sample_num;
                        continue;
                    end
                end

                % number of symbols in the packet
                sym_num = self.calc_sym_num(self.payload_len);

                % demodulate the rest LoRa data symbols
                if x > length(self.sig) - sym_num*self.sample_num + 1
                    return;
                end
                for ii = 8:sym_num-1
                    pk = self.dechirp(x+ii*self.sample_num);
                    pk_list = [pk_list; pk];
                    symbols = [symbols; mod((pk(2)+self.bin_num-self.preamble_bin)/self.zero_padding_ratio, 2^self.sf)];
                end
                x = x + sym_num*self.sample_num;

                % compensate CFO drift
                symbols = self.dynamic_compensation(symbols);

                symbols_m = [symbols_m mod(round(symbols),2^self.sf)];
                cfo_m = [cfo_m self.cfo];
            end

            if isempty(symbols_m)
                warning('No preamble detected!');
            end
        end

        function tag_data_matrix = PPLoRa_demodulate(self)
            tag_data_matrix = zeros(self.tag_num + 1, 6);
        
            for i = 1:6
                index = (10.25 + i - 1) * self.sample_num;
                rs = self.PPLoRa_dechirp(index);
        
                num_rows_rs = size(rs, 1); % 获取rs的行数
        
                tag_frequencies = zeros(num_rows_rs - 1, 1); % 用于存储每个非第一行与第一行差值对应的频率
        
                for x = 2:num_rows_rs
                    % 计算每个非第一行与第一行差值对应的频率
                    tag_frequencies(x - 1) = (abs(rs(x, 1) - rs(1, 1))) * self.fs / self.fft_len;
                end
        
                % 判断是否有频率在256000或者260000附近
                near_256000 = any(abs(tag_frequencies - 256000) < 1000);
                near_260000 = any(abs(tag_frequencies - 260000) < 1000);
        
                % 根据判断结果设置tag_data1和tag_data2的值
                if near_256000 
                    tag_data1 = 1;
                else
                    tag_data1 = 0;
                end
        
                if near_260000
                    tag_data2 = 1;
                else
                    tag_data2 = 0;
                end
        
                % 将相关数据填充到tag_data_matrix中
                tag_data_matrix(1, i) = rs(1, 1) / self.zero_padding_ratio;
                tag_data_matrix(2, i) = tag_data1;
                tag_data_matrix(3, i) = tag_data2;
            end
        end

        function s = PPLoRa_modulate(self, data, tag_offset)
            % modulate  Modulate a baseband signal 采用OOK调制
            % 这一步要在modulate以后进行
            % 考虑到第一版硬件没有检测前导码功能，所以这里会对所有接受到的信号进行偏移
            %
            % input:
            %     symbols: 需要编码的tag数据，
            %              valid symbol range: 0 or 1
            % output:
            %     s: A valid LoRa baseband signal
            % 默认tag偏移为256kHz
            if nargin < 3; tag_offset = 256e3; end
                
            t = (0:length(self.sig)-1)'/self.fs;
            % 确定切分点
            % split_point = round(length(t) / 2); % 前半部分和后半部分的分割点
            split_point = length(t);

            % 前半部分为矩形脉冲
            mix_sig = zeros(size(t)); % 初始化为 0
            mix_sig(1:split_point) = (square(2*pi*tag_offset*t(1:split_point), 50) + 1) / 2;

            % 后半部分为 1
            mix_sig(split_point+1:end) = 1;

            % mix_sig = (square(2*pi*tag_offset*t,50)+1)/2;
            s = mix_sig.*self.sig;
        end

        function s = new_PPLoRa_modulate(self, data, sig, tag_offset)
            % modulate  Modulate a baseband signal 采用OOK调制
            % 根据新要求对信号进行处理，以self.sample_num为一个符号单位
            % 对于10.25个self.sample_num以后的每个self.sample_num，按照data里的数字进行操作
            % 如果是1就乘上方波，如果是0就不处理，同时保留前10.25个self.sample_num的信号在原位置返回
        
            % input:
            %     data: 需要编码的tag数据，valid symbol range: 0 or 1
            % output:
            %     s: A valid LoRa baseband signal
            % 默认tag偏移为256kHz
            if nargin < 4; tag_offset = 256e3; end
        
            t = (0:length(sig)-1)'/self.fs;
        
            % 确定从第10.25个self.sample_num开始的索引
            start_index = round(10.25 * self.sample_num);
        
            % 初始化输出信号
            s = zeros(size(sig));
        
            % 先将前10.25个self.sample_num的信号赋值到输出信号s的对应位置
            s(1:start_index) = sig(1:start_index);
        
            % 遍历数据和对应的信号部分进行调制，从10.25个self.sample_num之后开始
            for i = start_index:self.sample_num:length(sig)
                index_in_data = floor((i - start_index) / self.sample_num) + 1;
                if index_in_data <= length(data)
                    if data(index_in_data) == 1
                        % 生成对应位置的方波并与信号相乘
                        s(i:i + self.sample_num - 1) = (square(2 * pi * tag_offset * t(i:i + self.sample_num - 1), 50) + 1) / 2.* sig(i:i + self.sample_num - 1);
                    else
                        % 如果是0，直接赋值原信号
                        s(i:i + self.sample_num - 1) = sig(i:i + self.sample_num - 1);
                    end
                end
            end
        end

        function is_valid = parse_header(self, data)
            % parse_header  Parse LoRa PHY header and set parameters
            %
            % input:
            %     data: An eight elements vector containing header symbols
            % output:
            %     is_valid: `true` if the header is valid
            %               `false` if the header is invalid

            % compensate CFO drift
            symbols = self.dynamic_compensation(data);

            % gray coding
            symbols_g = self.gray_coding(symbols);

            % deinterleave
            codewords = self.diag_deinterleave(symbols_g(1:8), self.sf-2);
            % parse header
            nibbles = self.hamming_decode(codewords, 8);
            self.payload_len = double(nibbles(1)*16 + nibbles(2));
            self.crc = double(bitand(nibbles(3), 1));
            self.cr = double(bitshift(nibbles(3), -1));
            % we only calculate header checksum on the first three nibbles
            % the valid header checksum is considered to be 5 bits
            % other 3 bits require further reverse engineering
            header_checksum = [bitand(nibbles(4), 1); de2bi(nibbles(5), 4, 'left-msb')'];
            header_checksum_calc = self.header_checksum_matrix * gf(reshape(de2bi(nibbles(1:3), 4, 'left-msb')', [], 1));
            if any(header_checksum ~= header_checksum_calc)
                warning('Invalid header checksum!');
                is_valid = 0;
            else
                is_valid = 1;
            end
        end

        function s = modulate(self, symbols)
            % modulate  Modulate a baseband signal
            %
            % input:
            %     symbols: A vector of chirp symbols to be modulated
            %              valid symbol range: 0 to 2^sf-1
            % output:
            %     s: A valid LoRa baseband signal

            uc = PPLoRa_PHY.chirp(true, self.sf, self.bw, self.fs, 0, self.cfo, 0);
            dc = PPLoRa_PHY.chirp(false, self.sf, self.bw, self.fs, 0, self.cfo, 0);
            preamble = repmat(uc, self.preamble_len, 1);
            netid = [PPLoRa_PHY.chirp(true, self.sf, self.bw, self.fs, 24, self.cfo, 0); PPLoRa_PHY.chirp(true, self.sf, self.bw, self.fs, 32, self.cfo, 0)];

            chirp_len = length(uc);
            sfd = [dc; dc; dc(1:round(chirp_len/4))];
            data = zeros(length(symbols)*chirp_len, 1);
            for i = 1:length(symbols)
                data((i-1)*chirp_len+1:i*chirp_len) =  PPLoRa_PHY.chirp(true, self.sf, self.bw, self.fs, symbols(i), self.cfo, 0);
            end
            s = [preamble; netid; sfd; data];
        end

        function symbols = encode(self, payload)
            % encode  Encode bytes to symbols
            %
            % input:
            %     payload: Payload of LoRa packet
            % output:
            %     symbols: A vector representing the symbols of the packet

            if self.crc
                data = uint8([payload; self.calc_crc(payload)]);
            else
                data = uint8(payload);
            end

            plen = length(payload);
            sym_num = self.calc_sym_num(plen);
            % filling all symbols needs nibble_num nibbles
            nibble_num = self.sf - 2 + (sym_num-8)/(self.cr+4)*(self.sf-2*self.ldr);
            data_w = uint8([data; 255*ones(ceil((nibble_num-2*length(data))/2), 1)]);
            data_w(1:plen) = self.whiten(data_w(1:plen));
            data_nibbles = uint8(zeros(nibble_num, 1));
            for i = 1:nibble_num
                idx = ceil(i/2);
                if mod(i, 2) == 1
                    data_nibbles(i) = bitand(data_w(idx), 0xf);
                else
                    data_nibbles(i) = bitshift(data_w(idx), -4);
                end
            end

            if self.has_header
                header_nibbles = self.gen_header(plen);
            else
                header_nibbles = [];
            end
            codewords = self.hamming_encode([header_nibbles; data_nibbles]);

            % interleave
            % first 8 symbols use CR=4/8
            symbols_i = self.diag_interleave(codewords(1:self.sf-2), 8);
            ppm = self.sf - 2*self.ldr;
            rdd = self.cr + 4;
            for i = self.sf-1:ppm:length(codewords)-ppm+1
                symbols_i = [symbols_i; self.diag_interleave(codewords(i:i+ppm-1), rdd)];
            end

            symbols = self.gray_decoding(symbols_i);
        end

        function header_nibbles = gen_header(self, plen)
            % gen_header  Generate a valid LoRa header
            %
            % input:
            %     plen: Payload length
            % output:
            %     header_nibbles: Header in nibbles

            header_nibbles = zeros(5, 1);
            header_nibbles(1) = bitshift(plen, -4);
            header_nibbles(2) = bitand(plen, 15);
            header_nibbles(3) = bitor(2*self.cr, self.crc);
            header_checksum = self.header_checksum_matrix * gf(reshape(de2bi(header_nibbles(1:3), 4, 'left-msb')', [], 1));
            x = header_checksum.x;
            header_nibbles(4) = x(1);
            for i = 1:4
                header_nibbles(5) = bitor(header_nibbles(5), x(i+1)*2^(4-i));
            end
        end

        function checksum = calc_crc(self, data)
            % calc_crc  Calculate payload CRC
            %
            % input:
            %     data: Data in bytes
            % output:
            %     checksum: CRC result

            switch length(data)
                case 0
                    checksum = [0; 0];
                case 1
                    checksum = [data(end); 0];
                case 2
                    checksum = [data(end); data(end-1)];
                otherwise
                    input = data(1:end-2);
                    seq = self.crc_generator(reshape(logical(de2bi(input, 8, 'left-msb'))', [], 1));
                    checksum_b1 = bitxor(bi2de(seq(end-7:end)', 'left-msb'), data(end));
                    checksum_b2 = bitxor(bi2de(seq(end-15:end-8)', 'left-msb'), data(end-1));
                    checksum = [checksum_b1; checksum_b2];
            end
        end

        function data_w = whiten(self, data)
            % whiten  Whitening process in LoRa
            %
            % input:
            %     data: Data in bytes
            % output:
            %     data_w: Data after whitening

            len = length(data);
            data_w = bitxor(data(1:len), self.whitening_seq(1:len));
            self.print_bin("Whiten", data_w);
        end

        function codewords = hamming_encode(self, nibbles)
            % hamming_encode  Hamming encoding process in LoRa
            %
            % input:
            %     nibbles: Data in nibbles
            % output:
            %     codewords: Data after hamming encoding

            nibble_num = length(nibbles);
            codewords = uint8(zeros(nibble_num, 1));
            for i = 1:nibble_num
                nibble = nibbles(i);

                p1 = PPLoRa_PHY.bit_reduce(@bitxor, nibble, [1 3 4]);
                p2 = PPLoRa_PHY.bit_reduce(@bitxor, nibble, [1 2 4]);
                p3 = PPLoRa_PHY.bit_reduce(@bitxor, nibble, [1 2 3]);
                p4 = PPLoRa_PHY.bit_reduce(@bitxor, nibble, [1 2 3 4]);
                p5 = PPLoRa_PHY.bit_reduce(@bitxor, nibble, [2 3 4]);
                if i <= self.sf - 2
                    % the first SF-2 nibbles use CR=4/8
                    cr_now = 4;
                else
                    cr_now = self.cr;
                end
                switch cr_now
                    case 1
                        codewords(i) = bitor(uint8(p4)*16, nibble);
                    case 2
                        codewords(i) = PPLoRa_PHY.word_reduce(@bitor, [uint8(p5)*32 uint8(p3)*16 nibble]);
                    case 3
                        codewords(i) = PPLoRa_PHY.word_reduce(@bitor, [uint8(p2)*64 uint8(p5)*32 uint8(p3)*16 nibble]);
                    case 4
                        codewords(i) = PPLoRa_PHY.word_reduce(@bitor, [uint8(p1)*128 uint8(p2)*64 uint8(p5)*32 uint8(p3)*16 nibble]);
                    otherwise
                        % THIS CASE SHOULD NOT HAPPEN
                        error('Invalid Code Rate!');
                end
            end
        end

        function symbols_i = diag_interleave(self, codewords, rdd)
            % diag_interleave  Diagonal interleaving
            %
            % input:
            %     codewords: Data in nibbles
            %     rdd: Bits with redundancy
            %          For example, code rate 4/5 means rdd = 5
            % output:
            %     symbols_i: Symbols after diagonal interleaving

            tmp = de2bi(codewords, rdd, 'right-msb');
            symbols_i = uint16(bi2de(cell2mat(arrayfun(@(x) circshift(tmp(:,x), 1-x), 1:rdd, 'un', 0))'));
            self.print_bin("Interleave", symbols_i);
        end

        function symbols = gray_decoding(self, symbols_i)
            % gray_decoding  Gray decoding
            %                `gray_decoding` is used in the ENCODING process
            %
            % input:
            %     symbols_i: Interleaved symbols
            % output:
            %     symbols: Final symbols to be modulated in a packet

            symbols = zeros(length(symbols_i), 1);
            for i = 1:length(symbols_i)
                num = uint16(symbols_i(i));
                mask = bitshift(num, -1);
                while mask ~= 0
                    num = bitxor(num, mask);
                    mask = bitshift(mask, -1);
                end
                if i <= 8 || self.ldr
                    symbols(i) = mod(num * 4 + 1, 2^self.sf);
                else
                    symbols(i) = mod(num + 1, 2^self.sf);
                end
            end
        end

        function sym_num = calc_sym_num(self, plen)
            % calc_sym_num  Calculate number of symbols
            %
            % input:
            %     plen: Payload length
            % output:
            %     sym_num: Number of symbols

            sym_num = double(8 + max((4+self.cr)*ceil(double((2*plen-self.sf+7+4*self.crc-5*(1-self.has_header)))/double(self.sf-2*self.ldr)), 0));
        end

        function plen = calc_payload_len(self, slen, no_redundant_bytes)
            % calc_payload_len  Calculate payload length
            %
            % input:
            %     slen: Number of symbols
            %     no_redundant_bytes: `true` to fill the 0.5 redundant bytes
            % output:
            %     plen: Payload length

            if nargin < 3
                no_redundant_bytes = false;
            end
            % plen_float possibly has fractional part 0.5, which means
            % there would be 0.5 uncontrollable redundant byte in a packet.
            % The 0.5 byte results in unexpected symbols when called by
            % function `symbols_to_bytes`. To make all specified symbols
            % controllable, we use `ceil` instead of `floor` when
            % no_redundant_bytes is true.
            plen_float = (self.sf-2)/2 - 2.5*self.has_header + (self.sf-self.ldr*2)/2 * ceil((slen-8)/(self.cr+4));
            if no_redundant_bytes
                plen = ceil( plen_float );
            else
                plen = floor( plen_float );
            end
        end

        function x_sync = sync(self, x)
            % sync  Packet synchronization
            %
            % input:
            %     x: Start index for synchronization
            % output:
            %     x_sync: Index after up-down alignment

            % find downchirp
            found = false;
            while x < length(self.sig) - self.sample_num
                up_peak = self.dechirp(x);
                down_peak = self.dechirp(x, false);
                if abs(down_peak(1)) > abs(up_peak(1))
                    % downchirp detected
                    found = true;
                end
                x = x + self.sample_num;
                if found
                    break;
                end
            end

            if ~found
                return;
            end

            % Up-Down Alignment
            % NOTE preamble_len >= 6
            % NOTE there are two NETID chirps between preamble and SFD
            % NOTE `detect` has already shifted the up peak to position 0
            pkd = self.dechirp(x, false);
            if pkd(2) > self.bin_num / 2
                to = round((pkd(2)-1-self.bin_num)/self.zero_padding_ratio);
            else
                to = round((pkd(2)-1)/self.zero_padding_ratio);
            end
            x = x + to;

            % set preamble reference bin for CFO elimination
            pku = self.dechirp(x - 4*self.sample_num);
            self.preamble_bin = pku(2);

            if self.preamble_bin > self.bin_num / 2
                self.cfo = (self.preamble_bin-self.bin_num-1)*self.bw/self.bin_num;
            else
                self.cfo = (self.preamble_bin-1)*self.bw/self.bin_num;
            end

            % set x to the start of data symbols
            pku = self.dechirp(x-self.sample_num);
            pkd = self.dechirp(x-self.sample_num, false);
            if abs(pku(1)) > abs(pkd(1))
                % current symbol is the first downchirp
                x_sync = x + round(2.25*self.sample_num);
            else
                % current symbol is the second downchirp
                x_sync = x + round(1.25*self.sample_num);
            end
        end

        function [data_m, checksum_m] = decode(self, symbols_m)
            % decode  Decode data from symbols
            %
            % input:
            %     symbols_m: A matrix of symbols to be decoded. Each column
            %                vector represents demodulated symbols from a
            %                LoRa packet.
            % output:
            %     data_m: A matrix of bytes representing the decoding
            %             result of `symbols_m`. The last two bytes are the
            %             decoded CRC checksum if CRC is enabled.
            %     checksum_m: A vector of checksum based on the decoded
            %                 payload.Checksum is empty if CRC is disabled.

            data_m = [];
            checksum_m = [];

            for pkt_num = 1:size(symbols_m, 2)
                % gray coding
                symbols_g = self.gray_coding(symbols_m(:, pkt_num));

                % deinterleave
                codewords = self.diag_deinterleave(symbols_g(1:8), self.sf-2);
                if ~self.has_header
                    nibbles = self.hamming_decode(codewords, 8);
                else
                    % parse header
                    nibbles = self.hamming_decode(codewords, 8);
                    self.payload_len = double(nibbles(1)*16 + nibbles(2));
                    self.crc = double(bitand(nibbles(3), 1));
                    self.cr = double(bitshift(nibbles(3), -1));
                    % we only calculate header checksum on the first three nibbles
                    % the valid header checksum is considered to be 5 bits
                    % other 3 bits require further reverse engineering
                    header_checksum = [bitand(nibbles(4), 1); de2bi(nibbles(5), 4, 'left-msb')'];
                    header_checksum_calc = self.header_checksum_matrix * gf(reshape(de2bi(nibbles(1:3), 4, 'left-msb')', [], 1));
                    if any(header_checksum ~= header_checksum_calc)
                        error('Invalid header checksum!');
                    end
                    nibbles = nibbles(6:end);
                end
                rdd = self.cr + 4;
                for ii = 9:rdd:length(symbols_g)-rdd+1
                    codewords = self.diag_deinterleave(symbols_g(ii:ii+rdd-1), self.sf-2*self.ldr);
                    % hamming decode
                    nibbles = [nibbles; self.hamming_decode(codewords, rdd)];
                end

                % combine nibbles to bytes
                bytes = uint8(zeros(min(255, floor(length(nibbles)/2)), 1));
                for ii = 1:length(bytes)
                    bytes(ii) = bitor(uint8(nibbles(2*ii-1)), 16*uint8(nibbles(2*ii)));
                end

                % dewhitening
                len = self.payload_len;
                if self.crc
                    % The last 2 bytes are CRC16 checkcum
                    data = [self.dewhiten(bytes(1:len)); bytes(len+1:len+2)];
                    % Calculate CRC checksum
                    checksum = self.calc_crc(data(1:len));
                else
                    data = self.dewhiten(bytes(1:len));
                    checksum = [];
                end
                data_m = [data_m data];
                checksum_m = [checksum_m checksum];
            end
        end

        function symbols = dynamic_compensation(self, data)
            % dynamic_compensation  Compensate bin drift
            %
            % input:
            %     data: Symbols with bin drift
            % output:
            %     symbols: Symbols after bin calibration

            % compensate the bin drift caused by Sampling Frequency Offset (SFO)
            sfo_drift = (1 + (1:length(data))') * 2^self.sf * self.cfo / self.rf_freq;
            symbols = mod(data - sfo_drift, 2^self.sf);

            if self.ldr
                bin_offset = 0;
                v_last = 1;

                for i = 1:length(symbols)
                    v = symbols(i);
                    bin_delta = mod(v-v_last, 4);
                    if bin_delta < 2
                        bin_offset = bin_offset - bin_delta;
                    else
                        bin_offset = bin_offset - bin_delta + 4;
                    end
                    v_last = v;
                    symbols(i) = mod(v+bin_offset, 2^self.sf);
                end
            end
        end

        function symbols = gray_coding(self, din)
            % gray_coding  Gray coding
            %              `gray_coding` is used in the DECODING process
            %
            % input:
            %     data: Symbols with bin drift
            % output:
            %     symbols: Symbols after bin calibration

            din(1:8) = floor(din(1:8)/4);
            if self.ldr
                din(9:end) = floor(din(9:end)/4);
            else
                din(9:end) = mod(din(9:end)-1, 2^self.sf);
            end
            s = uint16(din);
            symbols = bitxor(s, bitshift(s, -1));
            self.print_bin("Gray Coding", symbols, self.sf);
        end

        function codewords = diag_deinterleave(self, symbols, ppm)
            % diag_deinterleave  Diagonal deinterleaving
            %
            % input:
            %     symbols: Symbols after gray coding
            %     ppm: Size with parity bits
            % output:
            %     codewords: Codewords after deinterleaving

            b = de2bi(symbols, double(ppm), 'left-msb');
            codewords = flipud(bi2de(cell2mat(arrayfun(@(x) ...
                circshift(b(x,:), [1 1-x]), (1:length(symbols))', 'un', 0))'));
            self.print_bin("Deinterleave", codewords);
        end

        function bytes_w = dewhiten(self, bytes)
            % dewhiten  Data Dewhitening
            %
            % input:
            %     bytes: Bytes after deinterleaving
            % output:
            %     bytes_w: Bytes after dewhitening

            len = length(bytes);
            bytes_w = bitxor(uint8(bytes(1:len)), self.whitening_seq(1:len));
            self.print_bin("Dewhiten", bytes_w);
        end

        function nibbles = hamming_decode(self, codewords, rdd)
            % hamming_decode  Hamming Decoding
            %
            % input:
            %     codewords: Codewords after deinterleaving
            %     rdd: Bits with redundancy
            % output:
            %     nibbles: Nibbles after hamming decoding

            p1 = PPLoRa_PHY.bit_reduce(@bitxor, codewords, [8 4 3 1]);
            p2 = PPLoRa_PHY.bit_reduce(@bitxor, codewords, [7 4 2 1]);
            p3 = PPLoRa_PHY.bit_reduce(@bitxor, codewords, [5 3 2 1]);
            p4 = PPLoRa_PHY.bit_reduce(@bitxor, codewords, [5 4 3 2 1]);
            p5 = PPLoRa_PHY.bit_reduce(@bitxor, codewords, [6 4 3 2]);
            function pf = parity_fix(p)
                switch p
                    case 3 % 011 wrong b3
                        pf = 4;
                    case 5 % 101 wrong b4
                        pf = 8;
                    case 6 % 110 wrong b1
                        pf = 1;
                    case 7 % 111 wrong b2
                        pf = 2;
                    otherwise
                        pf = 0;
                end
            end
            if self.hamming_decoding_en
                switch rdd
                    % TODO report parity error
                    case {5, 6}
                        nibbles = mod(codewords, 16);
                    case {7, 8}
                        parity = p2*4+p3*2+p5;
                        pf = arrayfun(@parity_fix, parity);
                        codewords = bitxor(codewords, uint16(pf));
                        nibbles = mod(codewords, 16);
                    otherwise
                        % THIS CASE SHOULD NOT HAPPEN
                        error('Invalid Code Rate!');
                end
            else
                nibbles = mod(codewords, 16);
            end
            self.print_bin("Hamming Decode", codewords);
        end

        function bytes = symbols_to_bytes(self, symbols)
            % symbols_to_bytes  Derive the payload for a given symbol series
            %
            % input:
            %     symbols: Symbols to appear in the demodulation level
            % output:
            %     bytes: Payload bytes

            symbols = reshape(symbols, [length(symbols), 1]);
            self.init();
            self.hamming_decoding_en = false;
            payload_len_ = self.payload_len;

            if length(symbols) <= 4
                slen_tmp = 8 + self.has_header*(self.cr+4);
            else
                slen_tmp = 8 + ceil((length(symbols)-4*(1-self.has_header))/4) * (self.cr+4);
            end
            self.payload_len = self.calc_payload_len(slen_tmp, true);
            symbols_ = zeros(self.calc_sym_num(self.payload_len), 1);
            if self.has_header
                jj = 9;
            else
                jj = 1;
            end
            for ii = 1:4:length(symbols)
                if ii+3 <= length(symbols)
                    symbols_(jj:jj+3) = symbols(ii:ii+3);
                else
                    symbols_(jj:jj+3) = [symbols(ii:end); zeros(ii-length(symbols)+3, 1)];
                end
                if jj == 1
                    jj = 9;
                else
                    jj = jj + self.cr + 4;
                end
            end
            if self.has_header
                % construct header
                symbols_tmp = self.encode(zeros(self.payload_len, 1));
                symbols_(1:8) = symbols_tmp(1:8);
            end
            [bytes, ~] = self.decode(symbols_);
            if self.crc
                bytes = bytes(1:end-2);
            end

            self.hamming_decoding_en = true;
            self.payload_len = payload_len_;
        end

        function time_ms = time_on_air(self, plen)
            % time_on_air  Calculate the flying time of a LoRa packet
            %
            % input:
            %     plen: Payload length
            % output:
            %     time_ms: Flying time (in milliseconds)

            sym_num = self.calc_sym_num(plen);
            % milliseconds
            time_ms = (sym_num + 4.25 + self.preamble_len) * (2^self.sf/self.bw) * 1000;
        end

        function print_bin(self, flag, vec, size)
            if self.is_debug
                if nargin == 3
                    size = 8;
                end
                len = length(vec);
                fprintf("%s:\n", flag);
                for i = 1:len
                    fprintf("%s\n", dec2bin(round(vec(i)), size));
                end
                fprintf("\n");
            end
        end

        function print_hex(self, flag, vec)
            if self.is_debug
                len = length(vec);
                fprintf("%s: ", flag);
                for i = 1:len
                    fprintf("%s ", dec2hex(round(vec(i))));
                end
                fprintf("\n");
            end
        end

        function log(self, flag, data)
            if self.is_debug
                fprintf("%s: ", flag);
                len = length(data);
                for i = 1:len
                    fprintf("%d ", data(i));
                end
                fprintf("\n");
            end
        end

        function plot_peak(self, x)
            figure;
            c = [self.downchirp self.upchirp];
            for jj = 1:9
                for ii = 1:2
                    ft = fft(self.sig(x:x+self.sample_num-1).*c(:,ii), self.fft_len);
                    ft_ = abs(ft(1:self.bin_num)) + abs(ft(self.fft_len-self.bin_num+1:self.fft_len));
                    subplot(2, 9, (ii-1)*9+jj);
                    plot(ft_);
                end
                x = x + self.sample_num;
            end
        end
    end

    methods(Static)
        function b = bit_reduce(fn, w, pos)
            b = bitget(w, pos(1));
            for i = 2:length(pos)
                b = fn(b, bitget(w, pos(i)));
            end
        end

        function w = word_reduce(fn, ws)
            w = ws(1);
            for i = 2:length(ws)
                w = fn(w, ws(i));
            end
        end
        %调用
        %pk = PPLoRa_PHY.topn([ft_ (1:self.bin_num).'], 1);
        function y = topn(pks, n, padding, th)
            [y, p] = sort(abs(pks(:,1)), 'descend');
            if nargin == 1
                return;
            end
            nn = min(n, size(pks, 1));
            if nargin >= 3 && padding
                y = [pks(p(1:nn), :); zeros(n-nn, size(pks, 2))];
            else
                y = pks(p(1:nn), :);
            end
            if nargin == 4
                ii = 1;
                while ii <= size(y,1)
                    if abs(y(ii,1)) < th
                        break;
                    end
                    ii = ii + 1;
                end
                y = y(1:ii-1, :);
            end
        end

        function y = chirp(is_up, sf, bw, fs, h, cfo, tdelta, tscale)
            % chirp  Generate a LoRa chirp symbol
            %
            % input:
            %     is_up: `true` if constructing an up-chirp
            %            `false` if constructing a down-chirp
            %     sf: Spreading Factor
            %     bw: Bandwidth
            %     fs: Sampling Frequency
            %     h: Start frequency offset (0 to 2^SF-1)
            %     cfo: Carrier Frequency Offset
            %     tdelta: Time offset (0 to 1/fs)
            %     tscale: Scaling the sampling frequency
            % output:
            %     y: Generated LoRa symbol

            if nargin < 8
                tscale = 1;
            end
            if nargin < 7
                tdelta = 0;
            end
            if nargin < 6
                cfo = 0;
            end
            N = 2^sf;
            T = N/bw;
            samp_per_sym = round(fs/bw*N);
            h_orig = h;
            h = round(h);
            cfo = cfo + (h_orig - h) / N * bw;
            if is_up
                k = bw/T;
                f0 = -bw/2+cfo;
            else
                k = -bw/T;
                f0 = bw/2+cfo;
            end

            % retain last element to calculate phase
            t = (0:samp_per_sym*(N-h)/N)/fs*tscale + tdelta;
            snum = length(t);
            c1 = exp(1j*2*pi*(t.*(f0+k*T*h/N+0.5*k*t)));

            if snum == 0
                phi = 0;
            else
                phi = angle(c1(snum));
            end 
            t = (0:samp_per_sym*h/N-1)/fs + tdelta;
            c2 = exp(1j*(phi + 2*pi*(t.*(f0+0.5*k*t))));

            y = cat(2, c1(1:snum-1), c2).';
        end

        function spec(sig, fs, bw, sf)
            x = 0:1/sf:2^sf/bw;
            y = -bw/2:bw/2;
            p = fs/bw;
            win_length = 2^(sf-2);
            N = p*2^sf;
            s = spectrogram(sig,win_length,round(win_length*0.8),N);
            valid_data_len = round(2^sf/2*1.5);
            b = abs(s(valid_data_len:-1:1,:));
            c = abs(s(end:-1:end-valid_data_len+1,:));
            d = [b;c];
            figure;
            imagesc(x,y,d);
            colormap summer;
            title('时频图');
            xlabel('Time');
            ylabel('Frequency');
            set(gcf,'unit','normalized','position',[0.05,0.2,0.9,0.1]);
        end

        % Method `read` and `write` are copied from
        % https://github.com/gnuradio/gnuradio/blob/master/gr-utils/octave/read_complex_binary.m
        % https://github.com/gnuradio/gnuradio/blob/master/gr-utils/octave/write_complex_binary.m
        function v = read(filename, count)

            % usage: read(filename, [count])
            %
            %  open filename and return the contents as a column vector,
            %  treating them as 32 bit complex numbers
            %

            m = nargchk (1,2,nargin);
            if (m)
            usage (m);
            end

            if (nargin < 2)
            count = Inf;
            end

            f = fopen (filename, 'rb');
            if (f < 0)
            v = 0;
            else
            t = fread (f, [2, count], 'float');
            fclose (f);
            v = t(1,:) + t(2,:)*1i;
            [r, c] = size (v);
            v = reshape (v, c, r);
            end
        end

        function v = write(data, filename)

            % usage: write(data, filename)
            %
            %  open filename and write data to it
            %  Format is interleaved float IQ e.g. each
            %  I,Q 32-bit float IQIQIQ....
            %  This is compatible with read_complex_binary()
            %

            m = nargchk (2,2,nargin);
            if (m)
            usage (m);
            end

            f = fopen (filename, 'wb');
            if (f < 0)
            v = 0;
            else
            re = real(data);
            im = imag(data);
            re = re(:)';
            im = im(:)';
            y = [re;im];
            y = y(:);
            v = fwrite (f, y, 'float');
            fclose (f);
            end
        end
    end
end
